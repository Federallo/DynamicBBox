% setting document languate
\documentclass[italian]{article}

% setting italian font encoding
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{babel}

\begin{document}
\section*{Introduzione}
%Inserire introduzione

\section*{Tecnlogie utilizzate}
Nella seguente sezione saranno elencate le tecnologie utilizzate per lo sviluppo del progetto. Alcune di esse, essendo state utilizzate principalmente dal mio collega, Marco Bardazzi, verranno passate in rassegna più rapidamente.\\
Ciascuna di esse, comunque, è stata implementata in Python.
\subsection{LiDAR}
LiDAR, o Light Detection and Ranging, rappresenta uno strumeto di telerilevamento che determina la distanza di un oggetto o superfice, utilizzando impulsi laser che li vanno a colpire.\\
Il risultato di tale processo è una pointcloud.
\subsection{Datasets}
Affinché si avesse una generazione affidabile delle pointcloud a partire dai dataset, è stato necessario l'utilizzo di \textit{Arogverse} per l'acquisizione di scenari e modelli, e \textit{Blensor} per simulare scansioni LiDAR.\\
\subsubsection{Argoverse}
Argoverse è un dataset open-source, sviluppato dall'Università Carnegie Mellon e dal Georgia Institute of Tecnology negli Stati Uniti. Le mappe disponibili includono metadati, utili per lo sviluppo di sistemi a guida autonoma.\\
I dati sono stati raccolti in Miami e Pittsburgh, due città caratterizzate da due comportamenti di guida differenti. Nel progetto è stato analizzata la mappa di un incrocio di Pittsburgh, incluso uno storico dei veicoli passanti (specificando per ciascuno ID, posizioni e velocità).\\
Nonostante tali dati siano stati raccolti attraverso veicoli con telecamere e sensori LiDAR, questi ultimi non influenzano assolutamente il progetto.
\subsubsection{BlenSor}
BlenSor è un package dell'applicazione Blender che permette di simulare scansioni LiDAR. Sviluppata dall'Università di Salisburgo, ha come principale vantaggio quello di creare scenari che, nel caso della guida autonoma, nella realtà non sarebbero possibili o sarebbe troppo costoso riprodurli (come per esempio una sitazione di incidente).\\
Nel nostro caso è risultato cruciale sfruttare algoritmi di norma presenti in sensori, senza possederli fisicamente.\\
La simulazione tramite Blensor genera un file .csv per ogni istante simultato e contenente le coordinate dei punti della pointcloud (senza rumore e filtrati).%TODO aggiungere nota: per filtrati si intende che non sono presenti i punti che rappresentano il terreno.
\subsection{Open3D}
Open3D è una libreria open-source che dispone di funzionalità grafiche per programmi Python e C++. Le principali features sono la possibilità di creare strutture dati 3D, la presenza di algoritmi di data processing in 3D utilizzabili e l'accelerazione hardware per operazioni 3D più laboriose.\\
Per lo sviluppo del progetto è stata sfruttata per la clusterizzazione delle pointcloud e per la visualizzazione grafica.
\subsubsection{Pointcloud}
La pointcloud è una struttura dati che rappresenta un insieme di punti nello spazio 3D. Viene istanziata tramite \textit{geometry.PointCloud()} e i punti di coordinate (x,y,z) vengono aggiunti come \textit{utlityVector3dVector(list)}\\
\subsubsection*{Sottocampionamento}
Essendo il campionamento delle pointcloud tramite scansioni LiDAR molto elevato, è stato necessario sottocampionare le pointcloud per ridurre il numero di punti e velocizzare l'elaborazione. Attraverso \textit{pointcloud.voxeldownsample(size)}  viene sottocampionata la pointcloud a partire da cubi di lato \textit{size}. Questi ultimi dividono lo spazio 3D in griglie e per ciascun cubo, se presenta una serie di punti, ne viene mantenuto uno solo.
\subsubsection*{Clustering}
Open3D dispone di un algoritmo di clustering, \textit{pointcloud.cluster\_dbscan(eps, min\_points, print\_progress)}, che permette di clusterizzare i punti della pointcloud.\\
E' un metodo di raggruppamento di punti a una distanza e con un numero di punti minimo prestabiliti.\\
Ovviamente questo metodo viene sfruttato solo in due situazioni nel seguente progetto: per la prima creazione delle bounding box e per la clusterizzazione di punti esterni alle bounding box.
\subsubsection{Bounding Box}
Le Bounding box sono rettangoli (o parallelepipedi in 3D) che racchiude un insieme di punti della pointcloud.\\
Esistono tre categorie di bounding box:
\begin{itemize}
	\item Axis-Aligned Bounding Box (AABB): rappresenta una bounding box allineata con gli assi cartesiani. Dei tre è il più veloce da calcolare, ma può ricoprire più area del normale.
	\item Obriented Bounding Box (OBB): è una bounding box orientata in base alla forma della pointcloud. E' più accurata dell'AABB, ma richiede più tempo per essere calcolata.
	\item Minimum Bounding Box (MBB): individua la bounding box con la minima area che racchiude l'insieme di punti della pointcloud. Soprattutto in dimensioni superiori a due, richiede molto tempo per essere calcolata.
\end{itemize}
Allo scopo del progetto, è stata utilizzata la bounding box di tipo OBB, in quanto la più accurata per il nostro scopo.
Open3D offre la possibilità di creare le bounding box a partire dalla pointcloud utilizzando il metodo \textit{pointcloud.get\_oriented\_bounding\_box)}, il quale ritorna un oggetto \textit{geometry.OrientedBoundingBox}.\\
Inoltre, Open3D permette di assegnare un colore alle bounding box, utilizzando il metodo \textit{obb.color = [r,g,b]}.
\subsubsection*{Punti interni alla bounding box}
Lo scopo del progetto è quello di aggiornare le bounding box nel modo più rapido possibile. La funzione \textit{OrientedBoundingBox.get\_point\_indices\_within\_bounding\_box(pointcloud.points)} è cruciale per individuare i core points della pointcloud, da cui poi crearne il nuovo cluster e aggiornare la bounding box. Essenzialmente, analizza ogni singolo punto dato come argomento (in questo caso pointcloud.points) e ritorna un array di booleani, dove il valore true indica che il punto è interno alla bounding box. Un punto viene considerato tale se, proiettando il singolo punto sui tre assi, risulta compreso tra i valori minimi e massimi di ciascun asse, i quali sono definiti dall'attributo \textit{extent} della OBB.
Questo metodo è ottimizzato per pointcloud di grandi dimensioni e garantisce un'ottima accuratezza nell'individuare i punti.
\subsubsection*{Centro, estensione e orientazione della bounding box}
L'oggetto \textit{geometry.OrientedBoundingBox} dispone di tre attributi fondamentali:
\begin{itemize}
	\item center: rappresenta il centro della bounding box.
	\item extent: rappresenta l'estensione della bounding box.
	\item R: rappresenta la matrice di rotazione della bounding box.
\end{itemize}
Nell'esperimento, i seguenti dati hanno permesso di espandere la bounding box e, quindi, includere nuovi punti della pointcloud.
\subsubsection{Sfera}
Uno dei due metodi di clusterizzazione implementati è basato sulla creazione di sfera di bounding box. Open3D permette di istanziare un oggetto \textit{open3d.geometry.TriangleMesh}, che crea e manipola geometrie 3D a mesh triangolari. Una mesh triangolare è un tipo di mesh poligonale in cui la superficie di un oggetto 3D è composta da facce triangolari.\\
Il metodo \textit{open3d.geometry.TriangleMesh.create\_sphere(radius)} crea una sfera di raggio \textit{radius} centrata nel centroide della bounding box attraverso il metodo \textit{translate(translation)}.\\
Essendo, a questo punto, una sfera che impedisce la visualizzazione dei punti interni, è stato necessario trasformarla in un wireframe. Istanziando un oggetto \textit{open3d.geometry.LineSet.create\_from\_triangle\_mesh(mesh)}, quest'ultima estrae dalla mesh della sfera i lati dei triangoli che la compongono, per permettere la visualizzazione dei punti interni.\\
\subsubsection{Draw}
Open3D offre la possibilità di visualizzare tramite interfaccia le pointcloud e le bounding box attraverso il metodo \textit{open3d.visualization.draw()}. E' possibile navigare liberamente all'interno della finestra, zoommando e ruotando gli oggetti.\\
Sono presenti, inoltre, parametri i quali permetto una visualizzazione più personalizzata come
\begin{itemize}
	\item mostrare o nascondere piani arbitrari oppure
	\item mostrare o nascondere gli assi di riferimento
\end{itemize}
Nel progetto è stata sfruttata soprattutto per avere una visualizzazione grafica che mostra ogni passaggio che effettua il programma.

\section*{Alogirtmi}
Nella seguente sezione verranno trattati gli algoritmi implementati per il progetto.
\subsection{Clustering}
Il clustering è un metodo di Unsupervised Learning che raggruppa un insieme di oggetti in classi simili. Tali classi possono essere definite in base alla forma, al colore o alla densità degli oggetti.\\
E' usato principalmente per l'esplorazione dei dati, per ridurne la complessità di ricerca oppure per raggrupparli in maniera efficiente oppure per comprimerli.\\
L'algoritmo usato nel seguente progetto che implementa il clustering è il DBSCAN.
\subsubsection{DBSCAN}
L'algoritmo DBSCAN divide i punti della pointcloud in batch o gruppi in base, in questo caso, alla densità.\\
Prima di descrivere l'argoritmo in dettaglio, è necessario definire le seguenti terminologie:
\begin{itemize}
	\item Core point: un punto è un core point se ha almeno un numero minimo di punti vicini, definiti \textit{minPts}, entro una certa distanza, chiamata \textit{epsilon} o \textit{eps}.
	\item Border point: un punto è un border point se non è un core point, ma è raggiungibile da un core point.
	\item Noise point: un punto è un noise point se non è nè un core point nè un border point.
\end{itemize}
I passi principali dell'algoritmo sono:
\begin{itemize}
	\item individua i core points.
	\item per ogni core point che non è stato assegnato a un cluster, ne crea uno nuovo, aggiungendo tutti i punti raggiungibili.
	\item cerca ricorsivamente i punti \textit{density-connected} e li aggiunge allo stesso cluster come core points. Per \textit{density-connected} si intende che due punti sono collegati se esiste un core point che li collega.		Quindi se un punto \textit{b} è raggiungibile da un punto \textit{a}, e un punto \textit{c} è raggiungibile da \textit{b}, allora \textit{c} è raggiungibile da \textit{a}.
	\item itera fino a quando tutti i punti sono assegnati a un cluster. Quelli che non appartengono a nessun cluster sono considerati noise points.
\end{itemize}
Rappresenta un algoritmo molto resistente a noise e può individuare cluster di forma arbitraria. La complessità dell'algoritmo è quadratica ($O(n^2)$)\\
Come accennato in precedenza, nel caso del progetto viene utilizzato per clusterizzare le pointcloud all'avvio del programma e ogni volta che ci sono nuove pointcloud da analizzare e non hanno una bounding box.
\subsubsection{DBSCAN personalizzato}
Per il progetto è stato necessario implementare un algoritmo di DBSCAN personalizzato, in quanto quello di Open3D non soddisfaceva i requisiti ed era necessario che prendesse in considerazione dei punti già clusterizzati come situazione di partenza e che completasse la creazione di un solo cluster per volta.\\
Quindi, partendo da delle bounding box già inizializzate (che vengono colorate di verde) e dalla pointcloud dello scan successivo, l'algoritmo compie i seguenti passaggi:
\begin{itemize}
	\item data la bounding box, individua gli indici dei punti interni sfruttando la funzione \textit{get\_point\_indices\_within\_bounding\_box()} che chiameremo \textbf{punti core}.
	\item a seconda del metodo di clusterizzazione scelto si espande/ si trasforma la bounding box in due modi differenti.
		\begin{itemize}
			\item dbscan\_expand\_bbox: espande la bounding box e riutilizza la stessa funzione per ottenere gli indici dei nuovi punti.
			\item dbscan\_sphere\_bound: genera una sfera con centro nel centroide della bounding box e di raggio pari alla dimensione maggiore della bounding box per un fattore di espansione dato in input, diviso due 					per indicare il raggio. Successiva individua gli indici dei punti interni alla sfera.
		\end{itemize}
	\item una volta individuati questi due set di indici, istanzia un array di label delle stesse dimensioni del numero di indici dei punti generati da \textit{dbscan\_expand\_bbox} o \textit{dbscan\_sphere\_bound} e si settano a -1, cioè come noise. Successivamente setta a 1 tutti quegli indici che sono presenti nei \textbf{punti core}.
	\item a questo punto viene applicato l'effettivo algoritmo dbscan, con la differenza che parte dai punti che hanno label 1 (e che quindi sono già considerati appartenenti a un cluster), cerca ricorsivamente i punti vicini e clusterizza quelli che hanno label -1.
	\item la lista di label viene sfruttata per creare un cluster, dal quale si genera la bounding box aggiornata che sarà colorata di rosso.
\end{itemize}
Questo approccio risulta molto più rapido ed efficace rispetto all'algoritmo implementato da open3d in quanto analizza solo singole porzioni di pointcloud per volta, cioè quelle presenti all'interno delle bounding box, parte da dei cluster già avviati e aggiunge solo i punti che sono vicini a questi ultimi, campionati in un determinato range stabilito dalla sfera o dalla bounding box espansa.\\
Ovviamente, se il numero minimo di punti per formare un cluster è troppo basso, l'oggetto non viene più seguito e non viene generata la bounding box aggiornata.
\subsection{Intersezione di bounding box}
Avendo la possibilità di poter clusterizzare pointcloud esterne alle bounding box, può capitare che in uno scan precedente si abbia una bounding box che contiene parte di un oggetto (in quanto il veicolo sta entrando nel range dei sensori) e che nello scan successivo si abbia una nuova bounding box che contiene la parte restante, o l'oggetto completo, ma che comunque si sovrappone alla precedente.\\
Perciò è stato necessario implementare un algoritmo che confronta le bounding box a coppie. Partendo dagli 8 vertici di ogni bounding box, si controlla se uno dei vertici di una è contenuto all'interno dell'altra. Questa operazione è possibile verificando la sovrapposizione(ovrelap) minima e massima di ciascun asse.\\
Dati come assi di riferimento i tre assi cartesiani:
\begin{itemize}
	\item l'overlap minimo viene calcolato tramite valore massimo di ciascuna delle coordinate interessate delle due bounding box prese in analisi che ha valore minimo.
	\item l'overlap massimo viene calcolato tramite valore minimo di ciascuna delle coordinate interessate delle due bounding box prese in analisi che ha valore massimo.
\end{itemize}
Se gli overlap massimi di ciascun asse sono maggiori degli overlap minimi, allora siginfica che le bounding box si sovrappongono e quindi viene rimossa quella che ha volume minore. Questo valore è ottenuto dalla funzione \textit{get\_volume()} che calcola il volume della bounding box come prodotto delle lunghezze dei tre lati.\\

\section*{Progetto}
Il seguente progetto consiste nell'aggiornare i bounding box generati inizialmente dall'algoritmo della repository blensor\_analysis per una maggiore velocità di esecuzione. A seconda delle necessità, la clusterizzazione delle pointcloud in istanti successivi viene effettuata o all'interno di una bounding box espansa oppure all'interno di una sfera.\\
I principali parametri che ne determineranno le prestazioni sono i tempi di esecuzione e la precisione delle bounding box.\\ %TODO la precisione delle bounding box va fatta solo tra i due metodi, mentre i tempi di esecuzione vanno confrontati anche con l'algoritmo blensor analysis
Il programma è strutturato nella seguente maniera:
\begin{itemize}
	\item importazione della prima scansione, generazione delle pointcloud e creazione delle prime bounding box
	\item aggiornamento delle bounding box a ogni scansione successiva e visualizzazione grafica di ogni passaggio
	%TODO mettere grafici a confronto dei tempi di esecuzione
\end{itemize}
\subsection{Hardware e librerie utilizzati}
Le principali librerie e il package utilizzato per lo sviluppo dell'applicativo python sono:
\begin{itemize}
	\item blensor\_analysis: per la generazione delle prime bounding box e per la creazione delle pointcloud utili agli istanti successivi
	\item open3D
	\item numpy: per la gestione di array
\end{itemize}
Invece come hardware è stato utilizzato un computer con processore i5-10600k, 16GB di RAM e scheda video NVIDIA GeForce RTX 3070. Come IDE è stato utilizzato neovim.
\subsection{Note sul progetto}
Come detto in precedenza, si sta analizzando un incrocio di Pittsburgh, nel quale sono stati posizionati 5 sensori ad altezza 2.5 metri da terra. La frequenza di scansione, in base alla velocità media dei veicoli, è di 10Hz.\\
\subsection{importazione della prima scansione, generazione delle pointcloud e creazione delle prime bounding box}
In questa fase iniziale del progetto viene sfruttata la libreia \textit{blensoranalysis} che invoca i principali metodi della repository \textit{blensor\_analysis} per importare la pointcloud iniziale dal file \textit{.csv}, generarne i cluster e le bounding box, e visualizzare questi ultimi tramite output visivo.\\
In questo caso è stato scelto che le pointcloud venissero preventivamente filtrate, rimuovendo gli scan del terreno, e senza rumore, in quanto non fanno parte dello scopo del progetto.\\
\subsection{aggiornamento delle bounding box a ogni scansione successiva}
A questo punto, vengono coinvolte le librerie \textit{bbtracking.py}, \textit{dbscan\_expand\_bbox.py} (o \textit{dbscan\_sphere\_bound.py}) e \textit{blensoranalysis} per l'aggiornamento delle bounding box.\\
In \textit{bbtracking.py} vengono aggiornate iterativamente le bounding box iniziali considerando le pointcloud degli scan successivi, ottentute tramite libreria\textit{blensoranalysis}. Se durante il procedimento di aggiornamento delle bounding box una di esse contiene una pointcloud che non è abbastanza grande, allora viene eleminata e la pointcloud viene vista come noise.\\
Se durante l'aggiornamento delle bounding box in un determinato istante si presenta una nuova pointcloud che non è munita di bounding box, allora viene applicato il clustering di open3d e viene generata una nuova bounding box. Se quest'ultima si sovrappone a una bounding box già presente, allora viene rimossa quella con volume minore.\\
Per quanto riguarda la visualizzazione grafica, vengono mostrate le seguenti situazioni:
\begin{itemiz}
	\item quando si hanno le bounding box dell'iterazione corrente le bounding box dello scan succesivo.
	\item quando si effettua l'operazione di espasione delle bounding box generando una buonding box ingrandita oppure una sfera.
	\item quando ogni pointcloud è stata correttamente clusterizzata e la bounding box è stata aggiornata corettamente.
\end{itemize}

\section*{conclusioni}
Essendo in una situazione ideale 

\section{Descrizione dei file}
Nella seguente sezione vengono trattate nel dettaglio i singoli file del progetto.
\subsection{pointcloud}
Il seguente file contiene un solo metodo, generatePointCloud, il quale permette di generare la point cloud senza noise e filtrate a partire dal file .csv.\\
\subsection{blensoranalysis}
Il file blensoranalysis presenta metodi che servono da tramite tra DynamicBBox e la repository blensor\_analysis.
\begin{itemize}
		\item generateBoundingBox: il seguente metodo viene utilizzato per generare le bounding boxes al primo avvio del programma e vengono mostrate in output tramite liberia open3d. Come argomenti prende
			l'indice dello scan e il numero di sensori che eseguono lo scan. 
 		\item generateBB: genera le bounding box tramite pointcloud data in input e vengono aggiunte, in un momento successivo, alla lista di bounding box aggiornate.
\end{itemize}
\subsection{customdbscan}
In customdbscan viene preso l'algoritmo di DBSCAN e viene adattato allo scopo del progetto.\\
Sono stati implementati due modi diversi:
\subsubsection{Espansione della bounding box}
Impelementato nel file dbscan\_expand\_bbox, le bounding box vengono prima espanse e successivamente vengono clusterizzati i punti al loro interno.
I metodi implementati sono:
\begin{itemize}
	\item customDBSCAN: il metodo customDBSCAN prende come argomenti le point clouds dello scan successivo, la bounding box, il fattore di espansione delle bounding boxes, eps (distanza massima tra due punti per essere considerati nello stesso cluster) e minPts (numero minimo di punti per formare un cluster).\\ Inizialmente individua i punti interno alla bounding box. Successivamente li clusterizza assegnandogli un label.
	\item expandCluster: rappresenta il metodo che esegue la ricerca dei punti a distanza eps ddai neighbours e li aggiunge al cluster.
	\item expand\_bounding\_: è la funzione che espande effettivamente la bounding box data in input.
	\item pointsInBB: individua i punti interni alla bounding box.
	\item createBoundingBoxes: è la funzione che crea la bounding box dati i labels dei punti interni alla bounding box. Essenzialmente rimuove tutti quei label che individuano cluster più piccoli e crea la bounding box relativa al cluster più grande.
\end{itemize}
\subsubsection{Clusterizzazione dei punti vicini alla bounding box}
Implementato in dbscan\_near\_search, rispetto al metodo precedente non viene espansa la bounding box, ma nei metodi customDBSCAN e expandCluster vengono considerati anche i punti esterni alla bounding box. Quelli che sono vicini vengono aggiunti all lista dei points e dei labels.
\subsection{bbtracking}
Il seguente file presenta i seguenti metodi:
\begin{itemize}
	\item updateBB: il metodo updateBB aggiorna le buonding boxes date in input considerando le point clouds dello scan successivo usando customDBSCAN. Prima che venga invocato quest'ultimo, viene mostrato tramite open3d la situazione di partenza. Una volta aggiornate le bounding boxes, vengono analizzate le eventuali restanti point clouds che non erano presenti all'interno di queste ultime e ne vengono create nuove. Se delle bounding box si sovrappongono, vengono rimosse quelle più piccole. Se viene utilizzato il primo metodo di espansione delle bonding boxes, vengono prima mostrate le bounding boxes espanse e successivamente quelle aggiornate. Nel caso, invece, della clusterizzazione dei punti vicini, venogno mostrate le bounding box finali con i nouvi punti aggiunti di colore verde.
	\item findPointsOutsideBB: rappresenta la funzione che trova i punti esterni alle bounding boxes.
	\item removeOverlappingBoxes: rimuove le bounding boxes che si sovrappongono.
	\item displayBoundingBoxes: mostra le bounding boxes e le point clouds tramite open3d.
\end{itemize}
\subsection{main}
Il file main.py è il file principale del progetto, il quale inizializza le prime bounding box utilizzando metodi presenti nella repository blensor\_analysis implementati in blensoranalysis. Quest'ultima funge da tramite tra DynamicBBox e blensor\_analysis.\\
Tramite ciclo for vengono aggiornate le bounding boxes in base agli scan successivi.
\subsection{point}
\end{document}
