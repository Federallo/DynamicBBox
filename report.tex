% setting document languate
\documentclass[italian]{article}

% setting italian font encoding
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{microtype}
\usepackage{ragged2e}


\begin{document}
\justifying
\section*{Introduzione}
%Inserire introduzione

\section*{Tecnlogie utilizzate}
Nella seguente sezione saranno elencate le tecnologie utilizzate per lo sviluppo del progetto. Alcune di esse, essendo state utilizzate principalmente dal mio collega, Marco Bardazzi, e avendole sfruttate com punto di partenza, verranno passate in rassegna più rapidamente.\\
Ciascuna di esse, comunque, è stata implementata in Python.
\subsection{LiDAR}
LiDAR, o Light Detection and Ranging, rappresenta uno strumeto di telerilevamento che determina la distanza di un oggetto o superfice tramite l'utilizzo di impulsi laser.\\
Il risultato di tale processo è una pointcloud.
\subsection{Datasets}
Affinché si avesse una generazione affidabile delle pointcloud a partire dai dataset, è stato necessario l'utilizzo di due tecnologie in particolare:
\begin{itemize}
	\item\textit{Arogverse} per l'acquisizione di scenari e modelli 
	\item\textit{Blensor} per simulare scansioni LiDAR.
\end{itemize}
\subsubsection{Argoverse}
Argoverse è un dataset open-source di mappe, sviluppato dall'Università Carnegie Mellon e dal Georgia Institute of Tecnology negli Stati Uniti, le quali includono metadati utili per lo sviluppo di sistemi a guida autonoma.\\
Tali dati sono stati raccolti a Miami e a Pittsburgh, due città caratterizzate da due comportamenti di guida differenti. Nel progetto è stato analizzata la mappa di un incrocio di Pittsburgh, incluso uno storico dei veicoli passanti (specificando per ciascuno ID, posizioni e velocità).\\
Nonostante le informazioni siano state raccolti attraverso veicoli con telecamere e sensori LiDAR, questi ultimi non influenzano assolutamente lo scopo del progetto.
\subsubsection{BlenSor}
BlenSor è un package dell'applicazione Blender che permette di simulare scansioni LiDAR. Sviluppato dall'Università di Salisburgo, ha come principale vantaggio quello di creare scenari che, nel caso della guida autonoma, non sarebbere possibile rappresentarli nella realtà o sarebbe troppo costoso riprodurli (come per esempio una sitazione di incidente).\\
Nel nostro caso è risultato cruciale in quanto è stato possibile sfruttare algoritmi di norma presenti in sensori, senza possederli fisicamente.\\
La simulazione tramite Blensor genera un file .csv per ogni istante e contiene le coordinate dei punti della pointcloud (senza rumore e filtrati, cioè vengono rimossi quei punti che rappresentano il terreno).
\subsection{Open3D}
Open3D è una libreria open-source che dispone di funzionalità grafiche per programmi Python e C++. Le principali features sono:
\begin{itemize}
	\item la possibilità di creare strutture dati 3D
	\item la presenza di algoritmi di data processing in 3D utilizzabili 
	\item lo sfruttamento della GPU per velocizzare operazioni più laboriose.
\end{itemize}
Per lo sviluppo del progetto sono stati sfruttati soprattutto i metodi di clusterizzazione delle pointcloud e di creazione delle bounding box a partire da cluster finiti, insieme alla visualizzazione grafica.
\subsubsection{Pointcloud}
La pointcloud è una struttura dati che rappresenta un insieme di punti nello spazio 3D. Viene istanziata tramite \textit{geometry.PointCloud()} e i punti di coordinate (x,y,z) vengono aggiunti come \textit{utlityVector3dVector(list)}\\
\subsubsection*{Sottocampionamento}
Essendo il costo di campionamento delle pointcloud molto elevato a causa dell'alta densità di punti, è stato necessario sottocampionarle per avere una approssimazione accettabile in tempi ridotti. Attraverso \textit{pointcloud.voxeldownsample(size)}  viene sottocampionata la pointcloud attraverso cubi di lato \textit{size}. Questi ultimi dividono lo spazio 3D in griglie e se ciascun cubo presenta una serie di punti, ne verrà mantenuto uno solo.
\subsubsection*{Clustering}
Open3D dispone di un algoritmo di clustering, \textit{pointcloud.cluster\_dbscan(eps, min\_points, print\_progress)}, che permette di clusterizzare i punti della pointcloud.\\
E' un metodo di raggruppamento di punti che si basa sulla distanza tra di essi e su un numero di punti minimo prestabilito che sta a indicare la presenza di un cluster.\\
Ovviamente questo metodo viene sfruttato solo in due situazioni nel progetto: per la prima creazione delle bounding box e per la clusterizzazione di punti esterni alle bounding box.
\subsubsection{Bounding Box}
Le Bounding Box sono rettangoli (o parallelepipedi in 3D) che racchiudono un insieme di punti della pointcloud.\\
Esistono tre categorie di bounding box:
\begin{itemize}
	\item Axis-Aligned Bounding Box (AABB): rappresenta una bounding box allineata con gli assi cartesiani. Dei tre è il più veloce da calcolare, ma può ricoprire più area del normale.
	\item Obiented Bounding Box (OBB): è una bounding box orientata in base alla forma della pointcloud. E' più accurata dell'AABB, ma richiede più tempo per essere calcolata.
	\item Minimum Bounding Box (MBB): individua la bounding box con la minima area che racchiude l'insieme di punti della pointcloud. Soprattutto in dimensioni superiori a due, richiede molto tempo per essere calcolata.
\end{itemize}
Nel nostro caso è stata utilizzata la bounding box di tipo OBB, in quanto la più accurata per il nostro scopo.
Open3D offre la possibilità di creare le bounding box a partire dalla pointcloud utilizzando il metodo \textit{pointcloud.get\_oriented\_bounding\_box)}, il quale ritorna un oggetto \textit{geometry.OrientedBoundingBox}.\\
Inoltre, Open3D permette di assegnare un colore alle bounding box, utilizzando il metodo \textit{obb.color = [r,g,b]}.
\subsubsection*{Punti interni alla bounding box}
Siccome all'interno del programma sarà necessario aggiornare le bounding box nel modo più rapido possibile. La funzione \textit{OrientedBoundingBox.get\_point\_indices\_within\_bounding\_box(pointcloud.points)} ha permesso di individuare gli indici dei core points della pointcloud, da cui poi creare il nuovo cluster e aggiornare la bounding box.\\ 
Essenzialmente analizza un insieme punti della pointcloud dati come argomento alla funzione (in questo caso \textit{pointcloud.points}) e ritorna un array di booleani, dove il valore true indica che il punto è interno alla bounding box. Un punto viene considerato tale se, proiettato sui tre assi, risulta compreso tra i valori minimi e massimi determinati attraverso l'attributo \textit{extent} della OBB.\\
Questo metodo è ottimizzato per pointcloud di grandi dimensioni e garantisce un'ottima accuratezza nell'individuare i punti.
\subsubsection*{Centro, estensione e orientazione della bounding box}
L'oggetto \textit{geometry.OrientedBoundingBox} dispone di tre attributi fondamentali:
\begin{itemize}
	\item center: rappresenta il centroide della bounding box.
	\item extent: rappresenta l'estensione della bounding box. Sono tre valori che rappresentano l'altezza, la larghezza e la profondità della bounding box e rispettano l'orientamento di quest'ultima.
	\item R: rappresenta una matrice 3x3 che definisce l'orientamento della bounding box nello spazio tridimensionale.
\end{itemize}
Le seguenti informazioni hanno permesso di espandere la bounding box e includere nuovi punti alla porzione di pointcloud che si sta prendendo in analisi.
\subsubsection{Sfera}
Uno dei due metodi di clusterizzazione implementati prevede la creazione di una sfera a partire dai dati forniti da una bounding box. Open3D permette di istanziare un oggetto \textit{open3d.geometry.TriangleMesh} che crea e manipola geometrie 3D a mesh triangolari. Una mesh triangolare è un tipo di mesh poligonale in cui la superficie di un oggetto 3D è composta da facce triangolari.\\
Il metodo \textit{open3d.geometry.TriangleMesh.create\_sphere(radius)} crea una sfera di raggio \textit{radius} centrata nel centroide della bounding box attraverso il metodo \textit{translate(translation)}.\\
Essendo una sfera colorata, impedisce la visualizzazione dei punti interni: è stato necessario trasformarla in un wireframe. Istanziando un oggetto \textit{open3d.geometry.LineSet.create\_from\_triangle\_mesh(mesh)}, quest'ultimo permette di estrarre dalla mesh della sfera i lati dei triangoli che la compongono, così da permettere la visualizzazione dei punti interni.\\
\subsubsection{Draw}
Open3D offre la possibilità di visualizzare tramite interfaccia grafica le pointcloud e le bounding box attraverso il metodo \textit{open3d.visualization.draw()}, che permette anche di navigare liberamente all'interno della finestra,di zoommare e/o ruotare gli oggetti.\\
Sono presenti inoltre parametri che permettono una visualizzazione più personalizzata come
\begin{itemize}
	\item mostrare o nascondere piani arbitrari oppure
	\item mostrare o nascondere gli assi di riferimento
\end{itemize}
Le rappresentazioni tramite interfaccia grafica sono state sfruttate soprattutto per mostrare i passaggi che effettua il programma.

\section*{Alogirtmi}
Nella seguente sezione verranno trattati i principali algoritmi implementati per il progetto.
\subsection{Clustering}
Il clustering è un metodo di Unsupervised Learning che raggruppa un insieme di oggetti in classi simili. Tali classi possono essere di tipo morfologico, cromatico o basata sulle densità degli oggetti.\\
E' usato principalmente nell'esplorazione dei dati per ridurne la complessità di ricerca, per raggrupparli in maniera efficiente oppure per comprimerli.\\
L'algoritmo di clustering clustering implementato nel progetto è il DBSCAN.
\subsubsection{DBSCAN}
L'algoritmo DBSCAN divide i punti della pointcloud in batch o gruppi in base, in questo caso, alla densità.\\
Prima di descrivere l'argoritmo nel dettaglio, è necessario definire le seguenti terminologie:
\begin{itemize}
	\item Core point: un punto è un core point se ha almeno un numero minimo di punti vicini, il cui valore è chiamato \textit{minPts}, entro una certa distanza, chiamata \textit{epsilon} o \textit{eps}.
	\item Border point: un punto è un border point se non è un core point, ma è raggiungibile da un core point.
	\item Noise point: un punto è un noise point se non è nè un core point nè un border point.
\end{itemize}
I passi principali dell'algoritmo sono:
\begin{itemize}
	\item individua i core points.
	\item per ogni core point che non è stato assegnato a un cluster, ne crea uno nuovo, aggiungendo tutti i punti raggiungibili.
	\item cerca ricorsivamente i punti \textit{density-connected} e li aggiunge allo stesso cluster come core points. Per \textit{density-connected} si intende che due punti sono collegati se esiste un core point che li collega.		Quindi se un punto \textit{b} è raggiungibile da un punto \textit{a} (e quindi che si trova a una distanza massima \textit{eps}), e un punto \textit{c} è raggiungibile da \textit{b}, allora \textit{c} è raggiungibile da \textit{a}.
	\item ripete i passi precedenti fino a quando tutti i punti sono assegnati a un cluster. Quelli che non appartengono neanche a uno, sono considerati noise points.
\end{itemize}
Rappresenta un algoritmo molto resistente a noise e può individuare cluster di forma arbitraria. La complessità dell'algoritmo è quadratica ($O(n^2)$)\\
Come accennato in precedenza, nel caso del progetto viene utilizzato solo per clusterizzare le pointcloud all'avvio del programma e ogni volta che ci sono nuove pointcloud da analizzare e non hanno una bounding box associata.
\subsubsection{DBSCAN personalizzato}
Lo scopo di questo progetto è stato implementare un algoritmo di DBSCAN personalizzato che prendesse in considerazione dei punti già clusterizzati com situazione di partenza e che completasse la creazione di un solo cluster per volta, ma \textit{cluster\_dbscan} di Open3D non soddisfaceva qesti requisiti.\\
Quindi, partendo da delle bounding box già inizializzate (che vengono colorate di verde) e dalla pointcloud di uno scan successivo, l'algoritmo compie i seguenti passaggi:
\begin{itemize}
	\item data la bounding box, individua gli indici dei punti interni sfruttando la funzione \textit{get\_point\_indices\_within\_bounding\_box()} che chiameremo \textbf{punti core}.
	\item a seconda del metodo di clusterizzazione scelto si espande/ si trasforma la bounding box in due modi differenti.
		\begin{itemize}
			\item dbscan\_expand\_bbox: espande la bounding box creandone una nova aumentata di una percentuale prestabilita e riutilizza la stessa funzione per ottenere gli indici dei nuovi punti.
			\item dbscan\_sphere\_bound: genera una sfera con centro nel centroide della bounding box e di raggio pari alla dimensione maggiore della bounding box per un fattore di espansione dato in input, diviso due 					per indicare il raggio. Successivamente individua gli indici dei punti interni alla sfera.
		\end{itemize}
	\item una volta deifiniti questi due set di indici, istanzia un array di label delle stesse dimensioni del numero di indici dei punti generati dal file \textit{dbscan\_expand\_bbox} o \textit{dbscan\_sphere\_bound} e si settano a -1, cioè come noise. Successivamente setta a 1 tutti quegli indici che sono presenti anche nei \textbf{punti core}.
	\item a questo punto viene applicato l'effettivo algoritmo dbscan, con la differenza che parte dai punti che hanno label 1 (e che quindi sono già considerati appartenenti a un cluster), cerca ricorsivamente i punti vicini e clusterizza quelli che hanno label -1.
	\item la lista di label viene sfruttata per creare un solo cluster, dal quale si genera la bounding box aggiornata e sarà colorata di rosso.
\end{itemize}
Questo approccio risulta molto più rapido ed efficace rispetto all'algoritmo implementato da open3d in quanto analizza solo singole porzioni di pointcloud alla volta presenti all'interno delle bounding box, parte da dei cluster già avviati e aggiunge solo punti che sono stati inclusi dopo l'espansione della bounding box o la creazione di una sfera, e che sono vicini ai cluster.\\
Ovviamente, se in successivo scan il numero minimo di punti per formare un cluster è troppo basso, l'oggetto non viene più seguito e viene cancellata la bounding box associata.
\subsection{Intersezione di bounding box}
Avendo la possibilità di poter clusterizzare pointcloud esterne alle bounding box, può capitare che in uno scan precedente si abbia una bounding box che contiene solo parte di un oggetto (in quanto il veicolo sta ancora entrando nel range dei sensori) e che in un istante successivo si abbia una nuova bounding box che contiene la parte restante, o l'oggetto completo, ma che comunque si sovrappone alla precedente.\\
Perciò è risultato necessario implementare un algoritmo che confronta le bounding box a coppie. Partendo dagli 8 vertici di ciascuna bounding box, si controlla se i vertici di una sono contenuti, anche in parte, all'interno dell'altra. Questa operazione è possibile verificando la sovrapposizione(ovrelap) minima e massima di ciascun asse.\\
Dati come assi di riferimento i tre cartesiani:
\begin{itemize}
	\item l'overlap minimo viene calcolato tramite valore massimo di ciascuna delle coordinate interessate delle due bounding box prese in analisi che hanno valore minimo.
	\item l'overlap massimo viene calcolato tramite valore minimo di ciascuna delle coordinate interessate delle due bounding box prese in analisi che hanno valore massimo.
\end{itemize}
Se gli overlap massimi di ciascun asse sono maggiori degli overlap minimi, allora siginfica che le bounding box si sovrappongono e quindi viene rimossa quella che ha volume minore. Questo valore è ottenuto dalla funzione \textit{get\_volume()} che calcola il volume della bounding box come prodotto delle lunghezze dei tre lati.\\

\section*{Progetto}
Lo scopo del progetto consiste nell'aggiornare le bounding box generate inizialmente dall'algoritmo della repository \textit{blensor\_analysis} in modo da ottimizzare la clusterizzazione delle pointcloud interne alle bounding box. A seconda delle necessità, la clusterizzazione delle pointcloud in istanti successivi viene effettuata o all'interno di bounding box espanse oppure all'interno di sfere.\\
I principali parametri che ne determineranno le prestazioni sono i tempi di esecuzione e la precisione delle bounding box.\\ 
Il programma è strutturato nella seguente maniera:
\begin{itemize}
	\item importazione della prima scansione, generazione delle pointcloud e creazione delle prime bounding box
	\item aggiornamento delle bounding box a ogni scansione successiva e visualizzazione grafica di ogni passaggio
	%TODO mettere grafici a confronto dei tempi di esecuzione
\end{itemize}
\subsection{Hardware e librerie utilizzati}
Le principali librerie e il package utilizzato per lo sviluppo dell'applicativo python sono:
\begin{itemize}
	\item blensor\_analysis per la generazione delle prime bounding box e per la creazione delle pointcloud utili agli istanti successivi
	\item open3D
	\item numpy per la gestione di array
\end{itemize}
Come hardware invece è stato utilizzato un computer con processore i5-10600k, 16GB di RAM e scheda video NVIDIA GeForce RTX 3070. Come IDE è stato utilizzata neovim.
\subsection{Note sul progetto}
Come detto in precedenza, si sta analizzando un incrocio di Pittsburgh, nel quale sono stati posizionati 5 sensori ad altezza 2.5 metri da terra. La frequenza di scansione, in base alla velocità media dei veicoli, è di 10Hz.\\
\subsection{importazione della prima scansione, generazione delle pointcloud e creazione delle prime bounding box}
In questa fase iniziale del progetto viene sfruttato il modulo \textit{blensoranalysis} che invoca i principali metodi della repository \textit{blensor\_analysis} per importare la pointcloud iniziale dal rispettivo file \textit{.csv}, generarne i cluster e le bounding box, e visualizzare questi ultimi tramite output visivo.\\
In questo caso è stato deciso che le pointcloud venissero preventivamente filtrate, rimuovendo gli scan del terreno, e senza rumore, in quanto non fanno parte dello scopo del progetto.\\
\subsection{aggiornamento delle bounding box a ogni scansione successiva}
A questo punto, vengono coinvolti i moduli \textit{bbtracking.py}, \textit{dbscan\_expand\_bbox.py} (o \textit{dbscan\_sphere\_bound.py}) e \textit{blensoranalysis} per l'aggiornamento delle bounding box.\\
In \textit{bbtracking.py} vengono aggiornate le bounding box di partenza considerando la pointcloud dello scan successivo. Questi dati, insieme alle pointcloud degli scan successivi, sono ottentuti grazie ai metodi del modulo \textit{blensoranalysis}. Se durante il procedimento di aggiornamento delle bounding box una di esse contiene una porzione di pointcloud che non è abbastanza grande, allora viene eleminata e tale porzione viene considerata come noise.\\
Se durante l'aggiornamento delle bounding box in un determinato istante si presenta una nuova pointcloud che non è associata a nessuna bounding box, allora verrà applicato il clustering di Open3d che genera una nuova bounding box alla quale verrà associato il colore verde. Se quest'ultima si sovrappone a una bounding box già presente, allora viene rimossa quella con volume minore.\\
A livello visivo, verranno mostrate le seguenti situazioni:
\begin{itemize}
	\item quando si hanno le bounding box dell'iterazione corrente le bounding box dello scan succesivo.
	\item quando si effettua l'operazione di espasione delle bounding box generando una buonding box ingrandita oppure una sfera.
	\item quando si hanno nuovi cluster e quindi nuove bounding box.
	\item quando ogni pointcloud è stata correttamente clusterizzata e le bounding box sono state aggiornate corettamente.
\end{itemize}

\section*{Esiti}
Avendo preso in anlisi una situazione ideale di traffico, e cioè che i veicoli sono abbastanza distanziati da non causare errori nella creazione dei punti core e che non variano la direzione bruscamente, si ha che le bounding box aggiornate sono molto precise e che il tempo di esecuzione è sufficientemente basso.\\
\subsection{Tempo di esecuzione}
\subsection{precisione delle bounding box}
Considerando una situazione in cui la frenquenza di aggiornamento dei sensori è tale da far variare di poco lo spostamento degli oggeti, non si noterà grande differenza tra i due metodi di clusterizzazione.\\
Questa considerazione può essere più impattante nelle situazioni in cui i veicoli si muovono in modo brusco e in direzioni diverse, in quanto il metodo di espansione delle bounding box potrebbe non essere di reagire adeguatamente, mentre avendo una sfera come riferimento, è più probabile che includa eventuali punti in maniera più corretta.\\

\section*{Conclusioni}
Il progetto ha permesso di analizzare le bounding box di una pointcloud utilizzando due approcci differenti.\\
Rispetto alla normale clusterizzazione di open3d, non si nota un netto miglioramento nel tempo di creazione dei clustering. Questo è dovuto soprattutto al fatto che open3d sfrutta principalemnte la GPU, mente nel progetto, nonostante sono state analizzate solo porzioni di pointcloud per volta e che si è partiti da dei cluster già avviati, la potenza di calcolo del processore è risultata drasticamente più lenta soprattutto nella parte di ricerca dei punti vicini a una distanza \textit{eps} rispetto a quello che si sta analizzando.\\
Delle possibili migliorie nelle tecniche di clustering possono essere la ulteriore riduzione del tempo di esecuzione e un sistema di spostamento delle bounding box in base alla velocità dei veicoli.\\
Per quanto riguarda la prima considerazione, essendo dipendente soprattuto dalle elevate dimensioni dei file .csv da cui vengono lette le pointcloud (hanno un peso di circa 11MB), filtrati i punti che indicano il terreno e rimossi i noise. Inoltre, si potrebbe coinvolgere ulteriormente la GPU nel processo di clusterizzazione. Soprattutto nel caso del clustering di open3d è risultato un elemento importante per la velocità di esecuzione.\\
Non a caso vengono sfruttate soprattutto le schede video per elaborare grandi quantità di dati in tempo reale nella guida autonoma.\\
La procedura, in una situazione reale, verrebbe eseguita in tempo reale dai sensori, senza la necessità di dover leggere delle informazioni da dei file, quindi il problema del tempo di esecuzione non si porrebbe. Ma comunque, una possibile modifica sarebbe quella di andare a pre-filtrare le coordinate dei punti che rappresentano il terreno.\\
Per quanto riguarda la seconda considerazione, si potrebbe implementare un sistema di spostamento delle bounding box in base alla velocità dei veicoli e alla loro direzione di marci. Argoverse fornisce già questa possibilità, quindi sarebbe possibile implementare un sistema che, in base a queste informazioni, sposti le bounding box in modo da includere i nuovi punti che si stanno generando.\\
Tale integrazione risulta molto importante soprattutto in delle possbili situazioni di traffico intenso in quanto, dato che tutti i punti all'interno della bounding box vengono labelizzati a priori, c'è il rischio che consideri cluster anche parte di un oggetto che si trova in porssimità della bounding box, ma che non vi appartiene.\\

\end{document}
